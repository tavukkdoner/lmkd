{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "83ba6dfc_66d3bf3b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-06T18:13:43Z",
      "side": 1,
      "message": "What\u0027s the problem process_mrelease fails since the target was already terminated?",
      "range": {
        "startLine": 15,
        "startChar": 48,
        "endLine": 16,
        "endChar": 56
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64757bcc_2356ada4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-06T18:46:12Z",
      "side": 1,
      "message": "process_mrelease can reap the memory of the process more efficiently due to its high priority. Therefore memory will be released faster if process_mrelease can catch the process before it\u0027s considered gone.",
      "parentUuid": "83ba6dfc_66d3bf3b",
      "range": {
        "startLine": 15,
        "startChar": 48,
        "endLine": 16,
        "endChar": 56
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54db6651_23260cfb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-06T18:59:32Z",
      "side": 1,
      "message": "Then, please change the description \"process_mrelease to be **successful**\". It gave the impression, \"process_mrelease\" fails since the target process was already gone. \n\n```\nIn order to expedite killing, the time between the kill operation,,\n```",
      "parentUuid": "64757bcc_2356ada4",
      "range": {
        "startLine": 15,
        "startChar": 48,
        "endLine": 16,
        "endChar": 56
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e43e8d42_7bd12fd6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-06T18:13:43Z",
      "side": 1,
      "message": "Please write down rationale here why we should still relies on the cpu prio boosting instead of lmkd reap thread. I was thinking \"just reap queue and then multiple reaper thread could get it from the queue and handle it in parallel\".",
      "range": {
        "startLine": 20,
        "startChar": 27,
        "endLine": 20,
        "endChar": 70
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3b3cbbc_cf852e32",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-06T18:46:12Z",
      "side": 1,
      "message": "I didn\u0027t want to complicate the implementation with multiple reaper threads (which we can still extend in the future). So, right now we have one reaper thread and if it\u0027s busy when we need it them the main thread falls back to the original way of killing - it kills the process and waits for its exit with a timeout.",
      "parentUuid": "e43e8d42_7bd12fd6",
      "range": {
        "startLine": 20,
        "startChar": 27,
        "endLine": 20,
        "endChar": 70
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "797e61e6_062f6d03",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-06T18:59:32Z",
      "side": 1,
      "message": "I thought as-is made code more complicated because it introduced divergent handling, sometimes, reaper, sometimes, main thread..\n\nLet\u0027s think well known producer/consumer model. Here, lmkd main thread is just producer and always asking the killing to reaper, consumer thread. It would need list management but not hard with just single lock and then we will have more consistent handling with simple code. If we really need to handle parallel termination of processes, we could just create one more thread in reap.c, which is scalable and simple.",
      "parentUuid": "b3b3cbbc_cf852e32",
      "range": {
        "startLine": 20,
        "startChar": 27,
        "endLine": 20,
        "endChar": 70
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "237e141f_e0e212bc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-08T18:43:19Z",
      "side": 1,
      "message": "We do occasionally need parallel killing when killing takes longer than the timeout and we want to stop waiting and kill again. If I follow consumer/producer model we would need a thread pool. If we try to dynamically grow that thread pool it will be problematic because we need to add threads at the time of memory pressure, so might need allocations which can fail. So, more opportunities for a failure.\n\nIMHO the current mechanism of using reaper thread for one process only and if it\u0027s still busy main thread doing the killing without reaping is much simpler and will handle those occasional cases when the kill times out. WDYT?",
      "parentUuid": "797e61e6_062f6d03",
      "range": {
        "startLine": 20,
        "startChar": 27,
        "endLine": 20,
        "endChar": 70
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89b1d1c1_0ed25b75",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-08T18:58:59Z",
      "side": 1,
      "message": "If we need multiple killing in parallel, we could set up threads pool in advance up to max cpu number. We don\u0027t need to create them on the fly.\nI still believe the approach is better for both code and scalability point of view.",
      "parentUuid": "237e141f_e0e212bc",
      "range": {
        "startLine": 20,
        "startChar": 27,
        "endLine": 20,
        "endChar": 70
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d2c2208_30e582ca",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-08T19:03:18Z",
      "side": 1,
      "message": "Ok, that seems like a good option. Let me experiment with it. Thanks!",
      "parentUuid": "89b1d1c1_0ed25b75",
      "range": {
        "startLine": 20,
        "startChar": 27,
        "endLine": 20,
        "endChar": 70
      },
      "revId": "a79d72dac61fce3914c33016ae50cd278843f6a4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}