{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9b2b9c09_2d4b06dd",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2116,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T18:21:45Z",
      "side": 1,
      "message": "Can\u0027t you use some dynamic data structure here the language supports instead of raw static array?\n\nSo the producer just add new victim into the queue and that\u0027s all.",
      "range": {
        "startLine": 2116,
        "startChar": 19,
        "endLine": 2116,
        "endChar": 37
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "502957a0_8887ab46",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2116,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T19:39:41Z",
      "side": 1,
      "message": "I want to avoid dynamic allocations during memory pressure whenever possible.",
      "parentUuid": "9b2b9c09_2d4b06dd",
      "range": {
        "startLine": 2116,
        "startChar": 19,
        "endLine": 2116,
        "endChar": 37
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d25a41f5_40560b08",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2116,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T21:06:21Z",
      "side": 1,
      "message": "https://www.cplusplus.com/reference/vector/vector/reserve/\n\nI am not saying let\u0027s use vector but I point out they will provide some reserve function if you want to avoid dynamic allocation.\nAnd, let\u0027s think about how often lmkd calls the syscall which also could introduce dynamic allocation and sleeping on the lock.\nI am not saying \"we don\u0027t need to consider dynamic allocation at\" but just want to say not being too serious. Especially, the usecase once we reserved the amount of thread pool, it wouldn\u0027t be big problem in real practice like static arrary.",
      "parentUuid": "502957a0_8887ab46",
      "range": {
        "startLine": 2116,
        "startChar": 19,
        "endLine": 2116,
        "endChar": 37
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "621a0287_6eeddcba",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2116,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T22:00:09Z",
      "side": 1,
      "message": "Ok, I see what you mean.\nIn that case I think I don\u0027t even need a queue here because main thread submits processes for reaping one-by-one. I just need an additional counter to keep track of how many reaper threads are active to handle the case when all threads are busy (currently get_free_queue_pos() will return -1 in this case). So, previous reaper.pidfd should be just fine here.",
      "parentUuid": "d25a41f5_40560b08",
      "range": {
        "startLine": 2116,
        "startChar": 19,
        "endLine": 2116,
        "endChar": 37
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26c6ff54_6f1e7c02",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2154,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T18:21:45Z",
      "side": 1,
      "message": "Here, each thread just get the victim from the queue in FIFO order.\nOtherwise, just sleep if there is no target in the queue.",
      "range": {
        "startLine": 2154,
        "startChar": 11,
        "endLine": 2154,
        "endChar": 26
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b73279e_2497dbb2",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2154,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T19:39:41Z",
      "side": 1,
      "message": "Correct. All threads in the pool are sleeping here and as soon as reaper.req_cond is signaled one of them will pick up the work and execute which others will keep sleeping.",
      "parentUuid": "26c6ff54_6f1e7c02",
      "range": {
        "startLine": 2154,
        "startChar": 11,
        "endLine": 2154,
        "endChar": 26
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d2cbec8_a8736cec",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2154,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T21:06:21Z",
      "side": 1,
      "message": "What I meant is just use queue.pop() or something library to make code clean.",
      "parentUuid": "1b73279e_2497dbb2",
      "range": {
        "startLine": 2154,
        "startChar": 11,
        "endLine": 2154,
        "endChar": 26
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d078da63_dfbd30df",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2154,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T22:00:09Z",
      "side": 1,
      "message": "Previously used reaper.pidfd should be enough here. No queue is needed since main thread submits one job at a time and waits for the reaper thread to pick it up before proceeding.",
      "parentUuid": "1d2cbec8_a8736cec",
      "range": {
        "startLine": 2154,
        "startChar": 11,
        "endLine": 2154,
        "endChar": 26
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04e45b13_1b747a92",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2154,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T22:10:31Z",
      "side": 1,
      "message": "What I wanted to have with producer/consumer model was main thread just adds the target proc into the q. That\u0027s all. Do not wait other stuff since the job of main thread is just pick the target. And then consumer threads need to deal with the queue with a thread or thread pool whatever. Is there any something to prevent going that direction? If there is something hard to make it happen(guess some debugging log or something I have missed), can\u0027t we move those to align with that design?",
      "parentUuid": "d078da63_dfbd30df",
      "range": {
        "startLine": 2154,
        "startChar": 11,
        "endLine": 2154,
        "endChar": 26
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "457af910_1ceaa817",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2154,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T22:22:59Z",
      "side": 1,
      "message": "What prevents the main thread from just requesting and continuing is the fact that main thread should know whether the kill was successful or not before proceeding (did pidfd_send_signal() succeed or not). That\u0027s why we use reaper.kill_result to return that information back to the main thread. If the kill fails, main thread should immediately try to find another kill target and kill again.",
      "parentUuid": "04e45b13_1b747a92",
      "range": {
        "startLine": 2154,
        "startChar": 11,
        "endLine": 2154,
        "endChar": 26
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c30fab2_003f7542",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T18:21:45Z",
      "side": 1,
      "message": "What happens if cores has many little cores?\n\nWhat we want to achieve here is fast killing but defer to little cores wouldn\u0027t be opposite.\n\nOther questions: the threads LMKD create are also high-priority inherited thread?",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03f4ddef_1de9cf1f",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T19:39:41Z",
      "side": 1,
      "message": "Good point. I think we should call set_process_group_and_prio(tid, {\"CPUSET_SP_FOREGROUND\", \"SCHED_SP_FOREGROUND\"}, ANDROID_PRIORITY_HIGHEST) for these threads same way we boost killed process in kill_one_process().",
      "parentUuid": "2c30fab2_003f7542",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5df8eaf7_eca7ea1d",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T21:06:21Z",
      "side": 1,
      "message": "Still, we need to be careful on little cores. If we put the target on little core, it would be slow which is not intended from expedite kill.",
      "parentUuid": "03f4ddef_1de9cf1f",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c0087b3_74f5af2d",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T22:00:09Z",
      "side": 1,
      "message": "I think CPUSET_SP_FOREGROUND should prevent the threads from running on little cores. Am I missing something?",
      "parentUuid": "5df8eaf7_eca7ea1d",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c77619a6_5d1481cd",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1275554
      },
      "writtenOn": "2021-12-14T22:10:31Z",
      "side": 1,
      "message": "Maybe, Wei is good for answering the question. My concern were\n\n1. run on little cores - I\u0027m fine if it\u0027s solved by CPUSET\n2. mismatch cpu_count with thread pool if we target only middle/big cores for lmkd threads.",
      "parentUuid": "7c0087b3_74f5af2d",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a618bacc_1e4c0bc5",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1105075
      },
      "writtenOn": "2021-12-14T23:38:36Z",
      "side": 1,
      "message": "You probably want SCHED_SP_FOREGROUND to have prefer_idle or latency_sensitive, why we need those on big cores?",
      "parentUuid": "c77619a6_5d1481cd",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15409cc6_7dfb1ec4",
        "filename": "lmkd.cpp",
        "patchSetId": 1
      },
      "lineNbr": 3700,
      "author": {
        "id": 1157738
      },
      "writtenOn": "2021-12-14T23:40:36Z",
      "side": 1,
      "message": "I was planning to reuse the same call you had in kill_one_process for the victim process:\n\nset_process_group_and_prio(tid, {\"CPUSET_SP_FOREGROUND\", \"SCHED_SP_FOREGROUND\"}, ANDROID_PRIORITY_HIGHEST)\n\nIs that the best option to ensure quick memory release?",
      "parentUuid": "a618bacc_1e4c0bc5",
      "range": {
        "startLine": 3700,
        "startChar": 12,
        "endLine": 3700,
        "endChar": 21
      },
      "revId": "90c136687801614bfb454f75952446bbb975d5cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}